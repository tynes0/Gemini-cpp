#pragma once

#ifndef GEMINI_FILES_API_TYPES_H
#define GEMINI_FILES_API_TYPES_H

#include <climits>
#include <string>
#include <vector>
#include <optional>
#include <variant>

#include "../types_base.h"
#include "frenum.h"
#include "gemini/duration.h"
#include "gemini/support.h"
#include "gemini/url.h"

namespace GeminiCPP
{
    FrenumClassInNamespace(GeminiCPP, Source, uint8_t,
        SOURCE_UNSPECIFIED,
        UPLOADED,   // Indicates the file is uploaded by the user.
        GENERATED,  // Indicates the file is generated by Google.
        REGISTERED  // Indicates the file is a registered, i.e. a Google Cloud Storage file.
    )
    FrenumClassInNamespace(GeminiCPP, FileState, uint8_t,
        STATE_UNSPECIFIED,
        PROCESSING, // Processing file (Not immediately available)
        ACTIVE,     // Ready to use
        FAILED      // Processing error
    )

    // The Status type defines a logical error model that is suitable for different programming environments,
    // including REST APIs and RPC APIs. It is used by gRPC. Each Status message contains three pieces of data:
    // error code, error message, and error details.
    struct Status : IJsonSerializable<Status>
    {
        // The status code, which should be an enum value of google.rpc.Code.
        int code = 0;
        // A developer-facing error message, which should be in English. Any user-facing error message should be
        // localized and sent in the Status.details field, or localized by the client.
        std::string message;
        // A list of messages that carry the error details. There is a common set of message types for APIs to use.
        // An object containing fields of an arbitrary type. An additional field "@type" contains a URI identifying the type.
        // Example: { "id": 1234, "@type": "types.example.com/standard/id" }.
        std::vector<nlohmann::json> details;

        [[nodiscard]] static Status fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    // Metadata for a video File.
    struct VideoFileMetadata : IJsonSerializable<VideoFileMetadata>
    {
        // Duration of the video. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        Duration videoDuration;
        
        [[nodiscard]] static VideoFileMetadata fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    // A file uploaded to the API. Next ID: 15
    struct File : IJsonSerializable<File>
    {
        using MetadataType = std::variant<
            std::monostate,
            VideoFileMetadata // Output only. Metadata for a video.
        >;
        
        // Immutable. Identifier. The File resource name. The ID (name excluding the "files/" prefix) can contain up
        // to 40 characters that are lowercase alphanumeric or dashes (-). The ID cannot start or end with a dash.
        // If the name is empty on create, a unique name will be generated. Example: files/123-456
        ResourceName name;
        // Optional. The human-readable display name for the File. The display name must be no more
        // than 512 characters in length, including spaces. Example: "Welcome Image"
        std::optional<std::string> displayName;
        // Output only. MIME type of the file.
        std::string mimeType;
        // Output only. Size of the file in bytes.
        int64_t sizeBytes = 0;
        // Output only. The timestamp of when the File was created.
        Support::Timestamp createTime;
        // Output only. The timestamp of when the File was last updated.
        Support::Timestamp updateTime;
        // Output only. The timestamp of when the File will be deleted. Only set if the File is scheduled to expire.
        Support::Timestamp expirationTime;
        // Output only. SHA-256 hash of the uploaded bytes.
        Support::Base64String sha256Hash;
        // Output only. The uri of the File.
        std::string uri;
        // Output only. The download uri of the File.
        std::string downloadUri;
        // Output only. The download uri of the File.
        FileState state = FileState::STATE_UNSPECIFIED;
        // Source of the File.
        Source source = Source::SOURCE_UNSPECIFIED;
        // Output only. Error status if File processing failed.
        Status error;
        // Metadata for the File.
        MetadataType metadata;

        [[nodiscard]] static File fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct FilesGetRequestBody : IJsonSerializable<FilesGetRequestBody>
    {
        [[nodiscard]] static FilesGetRequestBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct FilesListQueryParameters : IJsonSerializable<FilesListQueryParameters>
    {
        // Optional. Maximum number of Files to return per page. If unspecified, defaults to 10. Maximum pageSize is 100.
        std::optional<int> pageSize;
        // Optional. A page token from a previous files.list call.
        std::optional<std::string> pageToken;

        [[nodiscard]] static FilesListQueryParameters fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct FilesListRequestBody : IJsonSerializable<FilesListRequestBody>
    {
        [[nodiscard]] static FilesListRequestBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct FilesListResponseBody : IJsonSerializable<FilesListResponseBody>
    {
        // The list of Files.
        std::vector<File> files;
        // A token that can be sent as a pageToken into a subsequent files.list call.
        std::string nextPageToken;

        [[nodiscard]] static FilesListResponseBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct FilesDeleteRequestBody : IJsonSerializable<FilesDeleteRequestBody>
    {
        [[nodiscard]] static FilesDeleteRequestBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct FilesDeleteResponseBody : IJsonSerializable<FilesDeleteResponseBody>
    {
        [[nodiscard]] static FilesDeleteResponseBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct MediaUploadRequestBody : IJsonSerializable<MediaUploadRequestBody>
    {
        // Optional. Metadata for the file to create.
        std::optional<File> file;

        [[nodiscard]] static MediaUploadRequestBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };

    struct MediaUploadResponseBody : IJsonSerializable<MediaUploadResponseBody>
    {
        // Metadata for the created file.
        File file;

        [[nodiscard]] static MediaUploadResponseBody fromJson(const nlohmann::json& j);
        [[nodiscard]] nlohmann::json toJson() const override;
    };
}

#endif // GEMINI_FILES_API_TYPES_H
